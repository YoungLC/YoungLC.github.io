### 1. python是按引用调用还是按值调用？

如果你在谷歌上搜索这个问题并阅读前几页，你就要准备好进入语义的迷宫了。你最好只是了解它的工作原理。

不可变对象（如字符串、数字和元组等）是按值调用的。请注意下面的例子，当在函数内部修改时，name的值在函数外部不会发生变化。name的值已分配给内存中该函数作用域的新块。


```python
name = 'chr'
def add_chars(s):   
    s += 'is'   
    print(s)
add_chars(name)    
print(name)
#=> chris
#=> chr
```

可变对象（如列表等）是通过引用调用的。注意下面的例子中，函数外部定义的列表在函数内部的修改是如何影响到函数外部的。函数中的参数指向内存中存储li值的原始块。

```python
li = [1,2]
def add_element(seq):   
    seq.append(3)   
    print(seq)
add_element(li)    
print(li)
#=> [1, 2, 3]
#=> [1, 2, 3]
```



### 2. Python中的实例方法、静态方法和类方法有什么区别**

   实例方法：**接受self参数，并且与类的特定实例相关。

   静态方法：**使用装饰器 @staticmethod，与特定实例无关，并且是自包含的（不能修改类或实例的属性）。

   类方法**：接受cls参数，并且可以修改类本身。

   我们将通过一个虚构的CoffeeShop类来说明它们之间的区别。

### 3. 浅拷贝和深拷贝之间有什么区别？**

我们将在一个可变对象（列表）的上下文中讨论这个问题，对于不可变的对象，浅拷贝和深拷贝的区别并不重要。
我们将介绍三种情况。
* 引用原始对象。这将新对象li2指向li1所指向的内存中的同一位置。因此，我们对li1所做的任何更改也会在li2中发生。

```python
li1 = [['a'],['b'],['c']]
li2 = li1
li1.append(['d'])
print(li2)
#=> [['a'], ['b'], ['c'], ['d']]
```

* 创建原始对象的浅拷贝副本。我们可以使用list()构造函数来实现这一点。浅拷贝创建一个新对象，但是用对原始对象的引用填充它。因此，向原始列表li3中添加新对象不会传播到li4中，但是修改li3中的一个对象将传播到li4中。
```python
li3 = [['a'],['b'],['c']]
li4 = list(li3)
li3.append([4])
print(li4)
#=> [['a'], ['b'], ['c']]
li3[0][0] = ['X']
print(li4)
#=> [[['X']], ['b'], ['c']]
```

* 创建一个深拷贝副本。这是用copy.deepcopy()完成的。现在，这两个对象是完全独立的，并且对其中一个对象所做的更改不会对另外一个对象产生影响。







